name: Build e Release do OberonAgente

on:
  push:
    tags:
      - 'v*.*.*' # Ex: v1.0.0, v2.1.5

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest] # Removido 'macos-latest'

    env:
      # Secrets do ambiente (preenchidos a partir dos Secrets do GitHub)
      USER_DB: ${{ secrets.USER_DB }}
      PASSWORD_DB: ${{ secrets.PASSWORD_DB }}
      HOST_DB: ${{ secrets.HOST_DB }}
      DATABASE_DB: ${{ secrets.DATABASE_DB }}
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      JIRA_URL: ${{ secrets.JIRA_URL }}
      JIRA_USER: ${{ secrets.JIRA_USER }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
      
      # Variáveis estáticas de ambiente
      EXECUTABLE_BASE_NAME: OberonAgente
      DIST_PATH: dist

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Configurar Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller python-dotenv

      - name: Gerar .env temporário com secrets
        shell: bash
        run: |
          set -e
          echo "USER_DB=${USER_DB}" > .env
          echo "PASSWORD_DB=${PASSWORD_DB}" >> .env
          echo "HOST_DB=${HOST_DB}" >> .env
          echo "DATABASE_DB=${DATABASE_DB}" >> .env
          echo "SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}" >> .env
          echo "JIRA_URL=${JIRA_URL}" >> .env
          echo "JIRA_USER=${JIRA_USER}" >> .env
          echo "JIRA_API_TOKEN=${JIRA_API_TOKEN}" >> .env
          echo "JIRA_PROJECT_KEY=${JIRA_PROJECT_KEY}" >> .env

      - name: Rodar PyInstaller
        shell: bash
        run: pyinstaller main.spec

      - name: Instalar zip (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install zip -y

      - name: Preparar arquivos para ZIP e definir variáveis de ambiente
        id: prepare_files
        shell: bash
        run: |
          set -e
          VERSION=${GITHUB_REF_NAME}
          BASE_NAME="${EXECUTABLE_BASE_NAME}"
          DIST_PATH="${DIST_PATH}"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            OS_SUFFIX="Windows"
            EXECUTABLE_EXT=".exe"
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            OS_SUFFIX="Linux"
            EXECUTABLE_EXT=""
          else
            OS_SUFFIX="macOS" 
            EXECUTABLE_EXT=""
          fi

          ZIP_NAME="${BASE_NAME}-${VERSION}-${OS_SUFFIX}.zip"

          # 1. Encontra o executável gerado
          # Busca com maxdepth 2 para cobrir casos como dist/app/app ou dist/app.exe
          # ATENÇÃO: Se o PyInstaller gera dist/OberonAgente/OberonAgente, o find retorna este caminho.
          EXECUTABLE_PATH=$(find "$DIST_PATH" -maxdepth 2 -type f -name "${BASE_NAME}${EXECUTABLE_EXT}" -print -quit)
          if [ -z "$EXECUTABLE_PATH" ]; then
            echo "Erro: Executável não encontrado!"
            exit 1
          fi

          TARGET_PATH="$DIST_PATH/${BASE_NAME}${EXECUTABLE_EXT}"

          if echo "$EXECUTABLE_PATH" | grep -q "$DIST_PATH/$BASE_NAME/"; then
            echo "Movendo executável aninhado de '$EXECUTABLE_PATH' para '$TARGET_PATH'"
            mv "$EXECUTABLE_PATH" "$TARGET_PATH"
          else
            echo "Executável já está na raiz de dist. Pulando mv."
          fi

          cp .env "$DIST_PATH/.env"

          echo "ZIP_NAME=$ZIP_NAME" >> $GITHUB_ENV
          echo "zip_name_output=$ZIP_NAME" >> $GITHUB_OUTPUT # Mantém o output para o Upload

      # Criar ZIP no Windows (PowerShell)
      - name: Criar ZIP Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Acessa as variáveis de ambiente promovidas ($env:ZIP_NAME)
          $Executable = "$env:EXECUTABLE_BASE_NAME.exe"
          
          $ExePath = Join-Path $env:DIST_PATH $Executable
          $EnvPath = Join-Path $env:DIST_PATH ".env"
          $DestPath = Join-Path $env:DIST_PATH $env:ZIP_NAME # Usa Join-Path para evitar erros de string

          # Compress-Archive usando caminhos seguros
          Compress-Archive -Path $ExePath, $EnvPath -DestinationPath $DestPath

      # Criar ZIP Linux/macOS (Bash)
      - name: Criar ZIP Linux/macOS
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # Acessa as variáveis de ambiente promovidas ($ZIP_NAME)
          zip -j "$DIST_PATH/$ZIP_NAME" "$DIST_PATH/$EXECUTABLE_BASE_NAME" "$DIST_PATH/.env"

      - name: Upload do ZIP como artefato
        uses: actions/upload-artifact@v4
        with:
          # Usa o output da etapa prepare_files (zip_name_output)
          name: ${{ steps.prepare_files.outputs.zip_name_output }}
          path: ${{ env.DIST_PATH }}/${{ steps.prepare_files.outputs.zip_name_output }}

  release:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Criar Release
        if: startsWith(github.ref, 'refs/tags/')
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false

      - name: Baixar todos os artefatos
        uses: actions/download-artifact@v4
        with:
          path: ./assets

      - name: Enviar assets à Release
        run: |
          set -e
          RELEASE_UPLOAD_URL="${{ steps.create_release.outputs.upload_url }}"
          find ./assets -name "*.zip" -print0 | while IFS= read -r -d $'\0' FILE
          do
            ASSET_NAME=$(basename "$FILE")
            echo "Enviando asset: $ASSET_NAME"
            curl -sSL \
              -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$FILE" \
              "$RELEASE_UPLOAD_URL?name=$ASSET_NAME"
          done