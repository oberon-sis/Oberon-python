name: Build e Release do OberonAgente

on:
  push:
    tags:
      - 'v*.*.*' # Ex: v1.0.0, v2.1.5

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest] # Removido 'macos-latest'

    env:
      # Secrets do ambiente (preenchidos a partir dos Secrets do GitHub)
      USER_DB: ${{ secrets.USER_DB }}
      PASSWORD_DB: ${{ secrets.PASSWORD_DB }}
      HOST_DB: ${{ secrets.HOST_DB }}
      DATABASE_DB: ${{ secrets.DATABASE_DB }}
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      JIRA_URL: ${{ secrets.JIRA_URL }}
      JIRA_USER: ${{ secrets.JIRA_USER }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
      
      # Variáveis estáticas de ambiente
      EXECUTABLE_BASE_NAME: OberonAgente
      DIST_PATH: dist

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Configurar Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Instalar dependências
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller python-dotenv

      - name: Gerar .env temporário com secrets
        shell: bash
        run: |
          set -e
          echo "USER_DB=${USER_DB}" > .env
          echo "PASSWORD_DB=${PASSWORD_DB}" >> .env
          echo "HOST_DB=${HOST_DB}" >> .env
          echo "DATABASE_DB=${DATABASE_DB}" >> .env
          echo "SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}" >> .env
          echo "JIRA_URL=${JIRA_URL}" >> .env
          echo "JIRA_USER=${JIRA_USER}" >> .env
          echo "JIRA_API_TOKEN=${JIRA_API_TOKEN}" >> .env
          echo "JIRA_PROJECT_KEY=${JIRA_PROJECT_KEY}" >> .env

      - name: Rodar PyInstaller
        shell: bash
        run: pyinstaller main.spec

      - name: Instalar zip (Linux)
        if: runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install zip -y

      - name: Preparar arquivos para ZIP e definir variáveis de ambiente
        id: prepare_files
        shell: bash
        run: |
          set -e
          VERSION=${GITHUB_REF_NAME}
          BASE_NAME="${EXECUTABLE_BASE_NAME}"
          DIST_PATH="${DIST_PATH}"

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            OS_SUFFIX="Windows"
            EXECUTABLE_EXT=".exe"
          elif [[ "$RUNNER_OS" == "Linux" ]]; then
            OS_SUFFIX="Linux"
            EXECUTABLE_EXT=""
          else
            OS_SUFFIX="Undefined" 
            EXECUTABLE_EXT=""
          fi

          ZIP_NAME="${BASE_NAME}-${VERSION}-${OS_SUFFIX}.zip"

          # 1. Encontra o executável gerado
          EXECUTABLE_PATH=$(find "$DIST_PATH" -maxdepth 2 -type f -name "${BASE_NAME}${EXECUTABLE_EXT}" -print -quit)
          if [ -z "$EXECUTABLE_PATH" ]; then
            echo "Erro: Executável não encontrado!"
            exit 1
          fi

          TARGET_FILENAME="${BASE_NAME}${EXECUTABLE_EXT}"
          TARGET_PATH="$DIST_PATH/$TARGET_FILENAME"
          TEMP_PATH="$DIST_PATH/temp_move_${TARGET_FILENAME}" # Novo caminho temporário

          if [[ "$EXECUTABLE_PATH" != "$TARGET_PATH" ]]; then
            echo "Executável aninhado encontrado: '$EXECUTABLE_PATH'. Movendo em duas etapas para garantir estabilidade."
            
            mv "$EXECUTABLE_PATH" "$TEMP_PATH"
            
            mv "$TEMP_PATH" "$TARGET_PATH"
            
            PARENT_DIR=$(dirname "$EXECUTABLE_PATH")
            if [ "$PARENT_DIR" != "$DIST_PATH" ]; then
              rmdir "$PARENT_DIR" 2>/dev/null || echo "Aviso: Não foi possível remover o diretório pai: $PARENT_DIR"
            fi
          else
            echo "Executável já está na raiz de dist. Pulando movimentação."
          fi

          # 3. Copia o .env
          cp .env "$DIST_PATH/.env"

          # 4. Promove o nome do ZIP para $GITHUB_ENV
          echo "ZIP_NAME=$ZIP_NAME" >> $GITHUB_ENV
          echo "zip_name_output=$ZIP_NAME" >> $GITHUB_OUTPUT # Mantém o output para o Upload

      # Criar ZIP no Windows (PowerShell)
      - name: Criar ZIP Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Acessa as variáveis de ambiente promovidas ($env:ZIP_NAME)
          $Executable = "$env:EXECUTABLE_BASE_NAME.exe"
          
          $ExePath = Join-Path $env:DIST_PATH $Executable
          $EnvPath = Join-Path $env:DIST_PATH ".env"
          $DestPath = Join-Path $env:DIST_PATH $env:ZIP_NAME # Usa Join-Path para evitar erros de string

          # Compress-Archive usando caminhos seguros
          Compress-Archive -Path $ExePath, $EnvPath -DestinationPath $DestPath

      # Criar ZIP Linux/macOS (Bash)
      - name: Criar ZIP Linux/macOS
        if: runner.os != 'Windows'
        shell: bash
        run: |
          # Acessa as variáveis de ambiente promovidas ($ZIP_NAME)
          zip -j "$DIST_PATH/$ZIP_NAME" "$DIST_PATH/$EXECUTABLE_BASE_NAME" "$DIST_PATH/.env"

      - name: Upload do ZIP como artefato
        uses: actions/upload-artifact@v4
        with:
          # Usa o output da etapa prepare_files (zip_name_output)
          name: ${{ steps.prepare_files.outputs.zip_name_output }}
          path: ${{ env.DIST_PATH }}/${{ steps.prepare_files.outputs.zip_name_output }}
  release:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: write

    steps:
      - name: Criar Release
        if: startsWith(github.ref, 'refs/tags/')
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false
      - name: Baixar todos os artefatos
        uses: actions/download-artifact@v4
        with:
          path: ./assets
          pattern: '*'
          merge-multiple: true 
          
      - name: Enviar assets à Release
        run: |
          set -e
          
          RELEASE_UPLOAD_URL_CLEANED=$(echo "${{ steps.create_release.outputs.upload_url }}" | sed 's/{?name,label}//')
          
          if [ $(find ./assets -name "*.zip" | wc -l) -eq 0 ]; then
            echo "Aviso: Nenhum arquivo .zip encontrado para upload."
            exit 0
          fi
          
          find ./assets -name "*.zip" -print0 | while IFS= read -r -d $'\0' FILE
          do
            ABSOLUTE_PATH="$PWD/$FILE"
            
            if [ ! -f "$ABSOLUTE_PATH" ]; then
                echo "Erro: Arquivo não encontrado/ilegível em: $ABSOLUTE_PATH"
                continue
            fi
            
            ASSET_NAME=$(basename "$FILE")
            echo "Enviando asset: $ASSET_NAME"
            
            FINAL_URL="${RELEASE_UPLOAD_URL_CLEANED}?name=$ASSET_NAME"
            
            curl -sSL \
              -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary "@$ABSOLUTE_PATH" \
              "$FINAL_URL"
          done